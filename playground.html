<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>Vector Visualizer with \vec{AE} = Expression</title>
        <style>
            /* CSS with semicolons */
            body {
                margin: 0;
                padding: 0;
                display: flex;
                font-family: sans-serif;
                height: 100vh;
            }
            #panel {
                width: 300px;
                padding: 10px;
                box-sizing: border-box;
                background: #f0f0f0;
                border-right: 1px solid #ccc;
                overflow-y: auto;
                position: relative;
            }
            #input_form {
                display: flex;
                gap: 5px;
                margin-bottom: 10px;
                position: relative;
            }
            #vector_input {
                flex: 1;
            }
            #canvas_container {
                position: relative;
            }
            #items_list {
                margin-top: 10px;
            }
            .item_entry {
                margin: 5px 0;
                padding: 5px;
                background: #ffffff;
                border: 1px solid #ccc;
                border-radius: 3px;
                word-break: break-all;
            }
            .item_title {
                font-weight: bold;
                margin-bottom: 3px;
            }
            .segment_description {
                margin-left: 10px;
                font-style: italic;
            }

            /* The autocomplete container also contains an error box at the bottom. */
            #autocomplete_container {
                position: absolute;
                background: #fff;
                border: 1px solid #ccc;
                border-radius: 3px;
                z-index: 9999;
                max-height: 200px;
                width: 100%;
                display: flex;
                flex-direction: column;
            }

            #autocomplete_suggestions {
                flex: 1 1 auto;
                overflow-y: auto;
            }
            #autocomplete_error {
                flex: 0 0 auto;
                color: red;
                font-size: 0.9em;
                background: #fff8f8;
                border-top: 1px solid #ccc;
                padding: 3px;
                min-height: 20px;
            }
            .autocomplete_item {
                padding: 5px;
                cursor: pointer;
                white-space: nowrap;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            .autocomplete_item:hover {
                background-color: #e0e0e0;
            }
            .autocomplete_selected {
                background-color: #d0d0d0;
            }
            .highlight_match {
                color: blue;
                font-weight: bold;
            }
            .autocomplete_desc {
                color: #999;
                font-size: 0.9em;
                margin-left: 10px;
            }
            /* Hidden mirror for caret measurement */
            #input_mirror {
                position: absolute;
                visibility: hidden;
                white-space: pre-wrap;
                word-wrap: break-word;
                overflow: auto;
            }
        </style>
    </head>
    <body>
        <div id="panel">
            <h3>Vector Visualizer</h3>
            <p>Examples:</p>
            <ul>
                <li><strong>A = 3i + 4j</strong> (Defines point A)</li>
                <li><strong>\vec{AB} + \vec{BC}</strong></li>
                <li><strong>\frac{\vec{AB}+2i+3j}{2}</strong></li>
                <li>
                    <strong>\vec{AE} = \frac{\vec{AB}}{4}</strong> (<em>Define point E</em> as \(A + \frac{AB}{4}\))
                </li>
            </ul>
            <div id="input_form">
                <input type="text" id="vector_input" placeholder="Enter expression" />
                <button id="add_vector_button">Add</button>

                <div id="autocomplete_container">
                    <div id="autocomplete_suggestions"></div>
                    <div id="autocomplete_error"></div>
                </div>
                <div id="input_mirror"></div>
            </div>

            <div id="items_list"></div>
        </div>

        <div id="canvas_container"></div>

        <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.js"></script>
        <script>
            /*
  We extend our logic so that if the user types:
    \vec{AE} = someVectorExpression

  we interpret that as E = A + (the displacement from the expression).
  Then we define (or update) point E accordingly.
  The rest of the code remains consistent with the multi-token intellisense, fraction support, etc.
*/

            // --------------------------------------------------------------------
            // Global data structures
            // --------------------------------------------------------------------
            let points_dict = {}
            let items = []
            let color_array = ["#e6194b", "#3cb44b", "#0082c8", "#f58231", "#911eb4", "#46f0f0", "#f032e6", "#ffe119"]
            let color_index = 0

            // p5 variables
            let scale_factor = 50
            let origin_x
            let origin_y

            // Autocomplete
            let autocomplete_container
            let autocomplete_suggestions
            let autocomplete_error
            let mirror_div
            let current_suggestions = []
            let selected_suggestion_index = 0
            const MAX_SUGGESTIONS = 5

            // For tokenizing
            const TOKEN_DELIMITERS = /(\s|\+|-|\(|\))/

            function setup() {
                let canvas = createCanvas(windowWidth - 300, windowHeight)
                canvas.parent("canvas_container")

                autocomplete_container = document.getElementById("autocomplete_container")
                autocomplete_suggestions = document.getElementById("autocomplete_suggestions")
                autocomplete_error = document.getElementById("autocomplete_error")
                mirror_div = document.getElementById("input_mirror")

                let input = document.getElementById("vector_input")

                // Press Enter => add if valid
                input.addEventListener("keydown", (event) => {
                    let full_str = input.value
                    let caretPos = input.selectionEnd || full_str.length
                    let { tokenText } = get_current_token(full_str, caretPos)

                    if (event.key === "Enter") {
                        event.preventDefault()
                        add_expression_if_valid()
                    } else if (event.key === "Tab") {
                        // Insert current suggestion
                        if (current_suggestions.length > 0) {
                            event.preventDefault()
                            let chosen = current_suggestions[selected_suggestion_index]
                            replace_last_token_with(chosen)
                            hide_autocomplete()
                        }
                    } else if (event.key === "ArrowDown") {
                        event.preventDefault()
                        selected_suggestion_index++
                        if (selected_suggestion_index >= current_suggestions.length) {
                            selected_suggestion_index = current_suggestions.length - 1
                        }
                        render_autocomplete_list(tokenText)
                    } else if (event.key === "ArrowUp") {
                        event.preventDefault()
                        selected_suggestion_index--
                        if (selected_suggestion_index < 0) {
                            selected_suggestion_index = 0
                        }
                        render_autocomplete_list(tokenText)
                    }
                })

                // As user types: validate & suggestions
                input.addEventListener("input", () => {
                    validate_current_input()
                    update_autocomplete()
                })

                // Hide autocomplete if click outside
                document.addEventListener("mousedown", (e) => {
                    let input_box = document.getElementById("vector_input")
                    if (!autocomplete_container.contains(e.target) && e.target !== input_box) {
                        hide_autocomplete()
                    }
                })
            }

            function windowResized() {
                resizeCanvas(windowWidth - 300, windowHeight)
            }

            function draw() {
                background(255)
                let bbox = compute_bounding_box()
                setup_view(bbox)
                draw_grid(bbox)
                draw_axes()
                draw_axis_labels(bbox)
                draw_axis_ticks(bbox)
                draw_items()
            }

            // --------------------------------------------------------------------
            // Add expression if valid
            // --------------------------------------------------------------------
            document.getElementById("add_vector_button").addEventListener("click", add_expression_if_valid)

            function add_expression_if_valid() {
                let error_msg = validate_current_input()
                if (error_msg) return

                let input_str = document.getElementById("vector_input").value.trim()
                if (!input_str) return

                parse_and_store(input_str)
                render_items_list()

                // reset
                document.getElementById("vector_input").value = ""
                autocomplete_error.textContent = ""
                hide_autocomplete()
                validate_current_input()
            }

            // --------------------------------------------------------------------
            // Validation => pinned error at bottom of intellisense
            // --------------------------------------------------------------------
            function validate_current_input() {
                let input_str = document.getElementById("vector_input").value.trim()
                let add_button = document.getElementById("add_vector_button")

                if (!input_str) {
                    autocomplete_error.textContent = ""
                    add_button.disabled = true
                    return "Empty"
                }
                let error_msg = test_parse_expression(input_str)
                if (error_msg) {
                    autocomplete_error.textContent = error_msg
                    add_button.disabled = true
                } else {
                    autocomplete_error.textContent = ""
                    add_button.disabled = false
                }
                return error_msg
            }

            /*
  test_parse_expression:
    1) \vec{XY} = ... => vector definition (define point Y)
    2) or if fraction => parse fraction
    3) or if "A = 2i+3j" => define point
    4) else standard vector expression
*/
            function is_fraction_expr(s) {
                return /\\frac\{.*?\}\{.*?\}/.test(s)
            }

            /**
             * test_parse_point(def_str):
             *   Checks if `def_str` looks like "A = 2i+3j"
             *   Returns null if valid, or an error string if invalid.
             */
            function test_parse_point(def_str) {
                // For example:
                let parts = def_str.split("=")
                if (parts.length !== 2) {
                    return "Invalid point definition (use A = 2i + 3j)"
                }
                let label = parts[0].trim()
                if (!label) {
                    return "Missing point label"
                }
                let coords_str = parts[1].trim()

                // If you have parse_position_vector, call it:
                let coords = parse_position_vector(coords_str)
                if (!coords) {
                    return "Invalid coordinates for point"
                }

                // If all is okay:
                return null
            }

            function test_parse_fraction_expr(expr_str) {
                // Check for proper \frac{...}{...} format
                let match = expr_str.match(/\\frac\{(.*?)\}\{(.*?)\}/)
                if (!match) {
                    return "Invalid fraction syntax; expected \\frac{...}{...}"
                }

                // numerator is match[1], denominator is match[2]
                let numerator = match[1].trim()
                let denominator_str = match[2].trim()

                // The numerator must be a valid vector expression
                let num_err = test_parse_vector_expr(numerator)
                if (num_err) {
                    return "Fraction numerator error: " + num_err
                }

                // The denominator must be a number
                let denominator_val = parseFloat(denominator_str)
                if (isNaN(denominator_val)) {
                    return "Fraction denominator must be a number"
                }
                if (Math.abs(denominator_val) < 1e-12) {
                    return "Fraction denominator cannot be zero"
                }

                // If everything checks out => no error
                return null
            }

            function test_parse_expression(expr_str) {
                // 1) check if it's a "vector definition" like "\vec{AE} = ..."
                if (is_vector_definition(expr_str)) {
                    return test_parse_vector_definition(expr_str)
                }
                // 2) fraction?
                if (is_fraction_expr(expr_str)) {
                    let frac_err = test_parse_fraction_expr(expr_str)
                    return frac_err
                }
                // 3) point definition? "A = 2i+3j"
                if (expr_str.includes("=")) {
                    return test_parse_point(expr_str)
                }
                // 4) standard vector expr
                return test_parse_vector_expr(expr_str)
            }

            // Checks if it matches \vec{XY} = ...
            function is_vector_definition(s) {
                // naive check: does s contain "\vec{", "=", and probably 2 letters?
                // We'll do a more robust parse in the test function
                return s.includes("\\vec{") && s.includes("=")
            }

            // Attempt to parse: \vec{AB} = <vector expression>
            // returns error string or null
            function test_parse_vector_definition(expr_str) {
                // split at '='
                let parts = expr_str.split("=")
                if (parts.length !== 2) {
                    return "Invalid vector definition (use \\vec{XY} = someVectorExpr)"
                }
                let left_side = parts[0].trim()
                let right_side = parts[1].trim()

                // parse the left side as \vec{XY}
                let named = parse_vec_label(left_side)
                if (!named) {
                    return "Left side must be \\vec{XY}"
                }
                // we need to ensure X is defined
                let X = named.a_label
                let Y = named.b_label
                if (!points_dict[X]) {
                    return `Point "${X}" not defined.`
                }

                // parse the right side as fraction or vector expr
                let err_msg = test_parse_expression(right_side)
                if (err_msg) {
                    return `Right side error: ${err_msg}`
                }
                return null
            }

            // parse_vec_label("\vec{AE}") => { a_label:'A', b_label:'E' } or null
            function parse_vec_label(str) {
                let s = str.replace(/\s+/g, "")
                s = s.replace(/\\vec\{/g, "")
                s = s.replace(/\}/g, "")
                // now s might be "AE"
                if (s.length < 2) return null
                let a = s.charAt(0)
                let b = s.charAt(1)
                return { a_label: a, b_label: b }
            }

            // --------------------------------------------------------------------
            //  parse_and_store
            // --------------------------------------------------------------------
            function parse_and_store(expr_str) {
                if (is_vector_definition(expr_str)) {
                    // \vec{XY} = ...
                    parse_vector_definition(expr_str)
                } else if (is_fraction_expr(expr_str)) {
                    let item = parse_fraction_expr(expr_str)
                    if (item) items.push(item)
                } else if (expr_str.includes("=")) {
                    // possibly "A = 2i+3j"
                    define_point_item(expr_str)
                } else {
                    // standard vector expr
                    let ve = parse_vector_expression(expr_str)
                    if (ve) items.push(ve)
                }
            }

            // parse_vector_definition("\vec{AE} = someExpr") => define E = A + (the displacement)
            function parse_vector_definition(full_str) {
                let parts = full_str.split("=")
                if (parts.length !== 2) return
                let left_side = parts[0].trim()
                let right_side = parts[1].trim()

                // parse left as \vec{AE}
                let named = parse_vec_label(left_side)
                if (!named) return
                let A_label = named.a_label
                let E_label = named.b_label

                // parse the right side as either fraction or normal vector expr
                // but we want the final net displacement (dx, dy)
                // We'll do the same approach as we do for "parse_vector_expression"
                // We'll store that as an item, or just parse the net displacement
                let displacement = parse_any_vector_expression_as_dxdy(right_side)
                if (!displacement) return // parse error

                // Now define point E if A is known
                if (!points_dict[A_label]) {
                    return // can't define E if A unknown
                }
                let Ax = points_dict[A_label].x
                let Ay = points_dict[A_label].y

                let Ex = Ax + displacement.dx
                let Ey = Ay + displacement.dy

                // create or update point E
                points_dict[E_label] = { x: Ex, y: Ey }
                // also store that point in items (like define_point_item)
                // If it already existed, we can either overwrite or do something else
                let existing_item = items.find((it) => it.type === "point" && it.label === E_label)
                if (!existing_item) {
                    items.push({
                        type: "point",
                        label: E_label,
                        x: Ex,
                        y: Ey,
                    })
                } else {
                    // update the existing point in the items list
                    existing_item.x = Ex
                    existing_item.y = Ey
                }
            }

            // parse_any_vector_expression_as_dxdy => returns {dx, dy} or null
            // It re-uses the fraction / vector expression logic but returns only net displacement.
            function parse_any_vector_expression_as_dxdy(expr_str) {
                // we can parse it as if it's a fraction or a normal vector expression
                if (is_fraction_expr(expr_str)) {
                    let item = parse_fraction_expr(expr_str)
                    if (!item) return null
                    // parse_fraction_expr returns a vectorExp with segments
                    let dxdy = final_displacement_of_vectorExp(item)
                    return dxdy
                } else if (expr_str.includes("=")) {
                    // user typed something else? We won't handle nested definitions
                    return null
                } else {
                    // treat as a normal vector expression
                    let item = parse_vector_expression(expr_str)
                    if (!item) return null
                    let dxdy = final_displacement_of_vectorExp(item)
                    return dxdy
                }
            }

            // final_displacement_of_vectorExp => looks at the last segment of the item
            function final_displacement_of_vectorExp(item) {
                // the net displacement is (end_of_last_segment - start_of_first_segment)
                // or we can accumulate each segment
                if (item.segments.length === 0) return { dx: 0, dy: 0 }

                // the first segment's start is (sx, sy)
                let sx0 = item.segments[0].sx
                let sy0 = item.segments[0].sy

                // the last segment's end is (ex, ey)
                let last = item.segments[item.segments.length - 1]
                let exN = last.ex
                let eyN = last.ey

                let dx = exN - sx0
                let dy = eyN - sy0
                return { dx, dy }
            }

            // parse_fraction_expr => returns vectorExp
            function parse_fraction_expr(expr_str) {
                let match = expr_str.match(/\\frac\{(.*?)\}\{(.*?)\}/)
                if (!match) return null
                let numerator = match[1].trim()
                let den_str = match[2].trim()
                let den_val = parseFloat(den_str)
                if (isNaN(den_val) || Math.abs(den_val) < 1e-12) return null

                let numerator_item = parse_vector_expression(numerator)
                if (!numerator_item) return null

                let new_item = {
                    type: "vectorExp",
                    expression: expr_str,
                    segments: [],
                }
                let sc = 1 / den_val
                let seg_in = numerator_item.segments
                if (seg_in.length === 0) return null

                let disps = []
                for (let s of seg_in) {
                    let dx = s.ex - s.sx
                    let dy = s.ey - s.sy
                    disps.push({ dx, dy, label: s.label })
                }
                let sx0 = seg_in[0].sx
                let sy0 = seg_in[0].sy
                let cx = sx0,
                    cy = sy0
                for (let d of disps) {
                    let ndx = d.dx * sc
                    let ndy = d.dy * sc
                    let nx = cx + ndx
                    let ny = cy + ndy
                    new_item.segments.push({
                        sx: cx,
                        sy: cy,
                        ex: nx,
                        ey: ny,
                        label: d.label,
                        color: get_next_color(),
                    })
                    cx = nx
                    cy = ny
                }
                if (disps.length > 1) {
                    new_item.segments.push({
                        sx: sx0,
                        sy: sy0,
                        ex: cx,
                        ey: cy,
                        label: "Fraction Sum",
                        color: get_next_color(),
                    })
                }
                return new_item
            }

            // define_point_item => "A = 2i+3j"
            function define_point_item(def_str) {
                let parts = def_str.split("=")
                if (parts.length !== 2) return
                let label = parts[0].trim()
                let coords_str = parts[1].trim()
                let coords = parse_position_vector(coords_str)
                if (!coords) return

                points_dict[label] = { x: coords.x, y: coords.y }
                items.push({
                    type: "point",
                    label,
                    x: coords.x,
                    y: coords.y,
                })
            }

            // parse_vector_expression => sum of terms
            function parse_vector_expression(expr) {
                let item = {
                    type: "vectorExp",
                    expression: expr,
                    segments: [],
                }
                let terms = expr.split("+").map((t) => t.trim())
                if (terms.length === 0) return null

                let parsed_terms = []
                for (let t of terms) {
                    let info = parse_vector_term_info(t)
                    if (!info) return null
                    parsed_terms.push(info)
                }
                if (parsed_terms.length === 1) {
                    let s = parsed_terms[0]
                    item.segments.push({
                        sx: s.start_coords.x,
                        sy: s.start_coords.y,
                        ex: s.end_coords.x,
                        ey: s.end_coords.y,
                        color: get_next_color(),
                        label: s.label,
                    })
                } else {
                    let first = parsed_terms[0]
                    let sx0 = first.start_coords.x
                    let sy0 = first.start_coords.y
                    let cx = sx0,
                        cy = sy0
                    for (let p of parsed_terms) {
                        let ex2 = cx + p.dx
                        let ey2 = cy + p.dy
                        item.segments.push({
                            sx: cx,
                            sy: cy,
                            ex: ex2,
                            ey: ey2,
                            color: get_next_color(),
                            label: p.label,
                        })
                        cx = ex2
                        cy = ey2
                    }
                    item.segments.push({
                        sx: sx0,
                        sy: sy0,
                        ex: cx,
                        ey: cy,
                        color: get_next_color(),
                        label: "Sum",
                    })
                }
                return item
            }

            function parse_vector_term_info(term_str) {
                let named = parse_named_vector(term_str)
                if (named) {
                    let dx = named.bx - named.ax
                    let dy = named.by - named.ay
                    return {
                        dx,
                        dy,
                        start_coords: { x: named.ax, y: named.ay },
                        end_coords: { x: named.bx, y: named.by },
                        label: named.label,
                    }
                }
                let coords = parse_position_vector(term_str)
                if (coords) {
                    return {
                        dx: coords.x,
                        dy: coords.y,
                        start_coords: { x: 0, y: 0 },
                        end_coords: { x: coords.x, y: coords.y },
                        label: term_str,
                    }
                }
                return null
            }

            function parse_named_vector(str) {
                let s = str.replace(/\s+/g, "")
                s = s.replace(/\\vec\{/g, "")
                s = s.replace(/\}/g, "")
                if (s.length < 2) return null
                let a = s.charAt(0)
                let b = s.charAt(1)
                return {
                    ax: points_dict[a] ? points_dict[a].x : 0,
                    ay: points_dict[a] ? points_dict[a].y : 0,
                    bx: points_dict[b] ? points_dict[b].x : 0,
                    by: points_dict[b] ? points_dict[b].y : 0,
                    point_a_label: a,
                    point_b_label: b,
                    label: "\\vec{" + a + b + "}",
                }
            }

            function parse_position_vector(str) {
                let s = str.toLowerCase().replace(/\s+/g, "")
                let m = s.match(/([+-]?\d*\.?\d*)i([+-]\d*\.?\d*)j/)
                if (!m) return null
                let x_str = m[1],
                    y_str = m[2]
                if (x_str === "" || x_str === "+") x_str = "1"
                else if (x_str === "-") x_str = "-1"
                if (y_str === "" || y_str === "+") y_str = "1"
                else if (y_str === "-") y_str = "-1"
                let x = parseFloat(x_str),
                    y = parseFloat(y_str)
                if (isNaN(x) || isNaN(y)) return null
                return { x, y }
            }

            function get_next_color() {
                let c = color_array[color_index % color_array.length]
                color_index++
                return c
            }

            /**
             * Check if a string is a valid "vector expression" without actually building the data.
             * Returns null if valid, or an error string if invalid.
             */
            function test_parse_vector_expr(expr) {
                // 1) Split on '+'
                let terms = expr.split("+").map((t) => t.trim())
                if (terms.length === 0) {
                    return "No valid expression"
                }

                // 2) Each term is either a named vector (\vec{AB}) or a position vector (2i+3j).
                //    We'll reuse your parse_named_vector and parse_position_vector to check validity.
                for (let t of terms) {
                    let check = test_parse_vector_term(t)
                    if (check) {
                        // if parse fails => return error string
                        return check
                    }
                }

                // 3) If all terms valid => no error
                return null
            }

            /**
             * Check a single term (e.g. "\vec{AB}" or "2i+3j") for correctness.
             * Returns null if valid, or an error string if invalid.
             */
            function test_parse_vector_term(term_str) {
                // 1) Try as named vector
                let named = parse_named_vector(term_str)
                if (named) {
                    // but we must check if the underlying points exist
                    let a_label = named.point_a_label
                    let b_label = named.point_b_label
                    if (!points_dict[a_label]) {
                        return `Point "${a_label}" is not defined`
                    }
                    if (!points_dict[b_label]) {
                        return `Point "${b_label}" is not defined`
                    }
                    return null
                }

                // 2) If not a named vector, try position vector
                let coords = parse_position_vector(term_str)
                if (coords) {
                    return null
                }

                // 3) If neither => invalid
                return `Unable to parse "${term_str}"`
            }

            // --------------------------------------------------------------------
            // bounding box & drawing
            // --------------------------------------------------------------------
            function compute_bounding_box() {
                if (items.length === 0) {
                    return { min_x: -1, max_x: 1, min_y: -1, max_y: 1 }
                }
                let min_x = Infinity,
                    max_x = -Infinity
                let min_y = Infinity,
                    max_y = -Infinity
                for (let it of items) {
                    if (it.type === "point") {
                        let x = it.x,
                            y = it.y
                        if (x < min_x) min_x = x
                        if (x > max_x) max_x = x
                        if (y < min_y) min_y = y
                        if (y > max_y) max_y = y
                    } else if (it.type === "vectorExp") {
                        for (let seg of it.segments) {
                            let vx1 = seg.sx,
                                vy1 = seg.sy
                            let vx2 = seg.ex,
                                vy2 = seg.ey
                            if (vx1 < min_x) min_x = vx1
                            if (vx1 > max_x) max_x = vx1
                            if (vy1 < min_y) min_y = vy1
                            if (vy1 > max_y) max_y = vy1
                            if (vx2 < min_x) min_x = vx2
                            if (vx2 > max_x) max_x = vx2
                            if (vy2 < min_y) min_y = vy2
                            if (vy2 > max_y) max_y = vy2
                        }
                    }
                }
                if (min_x === Infinity || max_x === -Infinity) {
                    return { min_x: -1, max_x: 1, min_y: -1, max_y: 1 }
                }
                return { min_x, max_x, min_y, max_y }
            }

            function setup_view(bbox) {
                let w = width,
                    h = height
                let margin = 40
                let bbw = bbox.max_x - bbox.min_x
                let bbh = bbox.max_y - bbox.min_y
                if (bbw < 0.0001) bbw = 1
                if (bbh < 0.0001) bbh = 1
                let scale_x = (w - 2 * margin) / bbw
                let scale_y = (h - 2 * margin) / bbh
                let new_scale = Math.min(scale_x, scale_y)
                if (!isFinite(new_scale) || new_scale <= 0) new_scale = 50
                scale_factor = new_scale
                let cx = (bbox.min_x + bbox.max_x) / 2
                let cy = (bbox.min_y + bbox.max_y) / 2
                origin_x = w / 2 - cx * scale_factor
                origin_y = h / 2 + cy * scale_factor
            }

            function draw_grid(bbox) {
                stroke(220)
                strokeWeight(1)
                noFill()
                let min_xi = Math.floor(bbox.min_x),
                    max_xi = Math.ceil(bbox.max_x)
                let min_yi = Math.floor(bbox.min_y),
                    max_yi = Math.ceil(bbox.max_y)
                for (let gx = min_xi; gx <= max_xi; gx++) {
                    let sx = origin_x + gx * scale_factor
                    let sy1 = origin_y - min_yi * scale_factor
                    let sy2 = origin_y - max_yi * scale_factor
                    line(sx, sy1, sx, sy2)
                }
                for (let gy = min_yi; gy <= max_yi; gy++) {
                    let sy = origin_y - gy * scale_factor
                    let sx1 = origin_x + min_xi * scale_factor
                    let sx2 = origin_x + max_xi * scale_factor
                    line(sx1, sy, sx2, sy)
                }
            }

            function draw_axes() {
                stroke(0)
                strokeWeight(2)
                line(0, origin_y, width, origin_y)
                line(origin_x, 0, origin_x, height)
            }

            function draw_axis_labels(bbox) {
                fill(0)
                noStroke()
                textSize(16)
                textAlign(CENTER, CENTER)
                let lx = bbox.max_x > 0 ? bbox.max_x : bbox.min_x
                let px = origin_x + lx * scale_factor + 30,
                    py = origin_y
                text("X", px, py)
                let ly = bbox.max_y > 0 ? bbox.max_y : bbox.min_y
                let qx = origin_x
                let qy = origin_y - ly * scale_factor - 20
                text("Y", qx, qy)
            }

            function draw_axis_ticks(bbox) {
                stroke(0)
                strokeWeight(1)
                fill(0)
                textSize(12)
                let x_range = bbox.max_x - bbox.min_x
                let y_range = bbox.max_y - bbox.min_y
                let x_step = pick_label_step(x_range)
                let y_step = pick_label_step(y_range)

                textAlign(CENTER, TOP)
                let min_xi = Math.floor(bbox.min_x),
                    max_xi = Math.ceil(bbox.max_x)
                for (let x = min_xi; x <= max_xi; x += x_step) {
                    let sx = origin_x + x * scale_factor
                    let sy = origin_y
                    line(sx, sy - 5, sx, sy + 5)
                    text(x, sx, sy + 5)
                }
                textAlign(RIGHT, CENTER)
                let min_yi = Math.floor(bbox.min_y),
                    max_yi = Math.ceil(bbox.max_y)
                for (let y = min_yi; y <= max_yi; y += y_step) {
                    let sy = origin_y - y * scale_factor
                    let sx = origin_x
                    line(sx - 5, sy, sx + 5, sy)
                    text(y, sx - 7, sy)
                }
            }
            function pick_label_step(range_val) {
                let ideal = 10
                let raw = range_val / ideal
                return choose_nice_step(raw)
            }
            function choose_nice_step(x) {
                let possible = [0.1, 0.2, 0.5, 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000]
                for (let st of possible) {
                    if (st >= x) {
                        if (st < 1) return 1
                        return st
                    }
                }
                return 1000
            }

            function draw_items() {
                for (let it of items) {
                    if (it.type === "point") draw_point_item(it)
                    else if (it.type === "vectorExp") draw_vector_exp_item(it)
                }
            }

            function draw_point_item(it) {
                let sx = origin_x + it.x * scale_factor
                let sy = origin_y - it.y * scale_factor
                fill(255, 0, 0)
                noStroke()
                circle(sx, sy, 8)
                fill(0)
                textSize(14)
                textAlign(LEFT, CENTER)
                text(it.label, sx + 10, sy)
            }

            function draw_vector_exp_item(it) {
                for (let seg of it.segments) {
                    let sx = origin_x + seg.sx * scale_factor
                    let sy = origin_y - seg.sy * scale_factor
                    let ex = origin_x + seg.ex * scale_factor
                    let ey = origin_y - seg.ey * scale_factor
                    stroke(seg.color)
                    strokeWeight(2)
                    line(sx, sy, ex, ey)
                    push()
                    translate(ex, ey)
                    let angle = atan2(sy - ey, sx - ex)
                    rotate(angle)
                    stroke(seg.color)
                    fill(seg.color)
                    let arrow_size = 7
                    line(0, 0, arrow_size, arrow_size / 2)
                    line(0, 0, arrow_size, -arrow_size / 2)
                    pop()
                }
            }

            // --------------------------------------------------------------------
            // Render the items list (points + vectors) in the left sidebar
            // --------------------------------------------------------------------
            function render_items_list() {
                let container = document.getElementById("items_list")
                container.innerHTML = ""
                for (let it of items) {
                    let entry = document.createElement("div")
                    entry.className = "item_entry"
                    if (it.type === "point") {
                        let t = document.createElement("div")
                        t.className = "item_title"
                        t.textContent = "Point " + it.label
                        entry.appendChild(t)
                        let inf = document.createElement("div")
                        inf.textContent = `Coordinates: (${it.x}, ${it.y})`
                        entry.appendChild(inf)
                    } else if (it.type === "vectorExp") {
                        let t = document.createElement("div")
                        t.className = "item_title"
                        t.textContent = "Vector Expression: " + it.expression
                        entry.appendChild(t)
                        let idx = 1
                        for (let s of it.segments) {
                            let seg_desc = document.createElement("div")
                            seg_desc.className = "segment_description"
                            seg_desc.style.color = s.color
                            seg_desc.textContent = `Segment #${idx}: from (${s.sx}, ${s.sy}) to (${s.ex}, ${s.ey}) [${s.label}]`
                            entry.appendChild(seg_desc)
                            idx++
                        }
                    }
                    container.appendChild(entry)
                }
            }

            // --------------------------------------------------------------------
            // Multi-Token Autocomplete (unchanged from prior examples)
            // --------------------------------------------------------------------
            function update_autocomplete() {
                let input = document.getElementById("vector_input")
                let full_str = input.value
                let caretPos = input.selectionEnd || full_str.length
                let { tokenText } = get_current_token(full_str, caretPos)

                if (!tokenText) {
                    hide_autocomplete()
                    return
                }

                let suggestions = build_all_suggestions()
                let partial_lc = tokenText.toLowerCase()
                let filtered = [...suggestions].filter((sug) => sug.toLowerCase().includes(partial_lc))
                filtered.sort((a, b) => {
                    let al = a.toLowerCase(),
                        bl = b.toLowerCase()
                    let a_st = al.startsWith(partial_lc)
                    let b_st = bl.startsWith(partial_lc)
                    if (a_st && !b_st) return -1
                    if (!a_st && b_st) return 1
                    return al.localeCompare(bl)
                })
                filtered = filtered.slice(0, MAX_SUGGESTIONS)

                if (filtered.length === 0) {
                    // If there's an error, we might still want to show container for the error
                    let err = autocomplete_error.textContent.trim()
                    if (err) {
                        show_autocomplete_container()
                        autocomplete_suggestions.innerHTML = ""
                    } else {
                        hide_autocomplete()
                    }
                    return
                }

                current_suggestions = filtered
                selected_suggestion_index = 0
                position_autocomplete_box()
                render_autocomplete_list(tokenText)
                show_autocomplete_container()
            }

            function render_autocomplete_list(tokenText) {
                autocomplete_suggestions.innerHTML = ""
                let partial_lc = tokenText.toLowerCase()

                current_suggestions.forEach((sug, idx) => {
                    let div = document.createElement("div")
                    div.className = "autocomplete_item"
                    if (idx === selected_suggestion_index) {
                        div.classList.add("autocomplete_selected")
                    }

                    let leftPart = document.createElement("span")
                    leftPart.innerHTML = highlight_partial(sug, partial_lc)

                    let rightPart = document.createElement("span")
                    rightPart.className = "autocomplete_desc"
                    rightPart.textContent = get_suggestion_description(sug)

                    div.appendChild(leftPart)
                    div.appendChild(rightPart)

                    div.addEventListener("mousedown", () => {
                        replace_last_token_with(sug)
                        hide_autocomplete()
                        validate_current_input()
                    })
                    autocomplete_suggestions.appendChild(div)
                })
            }

            function highlight_partial(suggestion, partial_lowercase) {
                let s_lower = suggestion.toLowerCase()
                let start_idx = s_lower.indexOf(partial_lowercase)
                if (start_idx < 0) return suggestion
                let end_idx = start_idx + partial_lowercase.length
                let prefix = suggestion.slice(0, start_idx)
                let match_text = suggestion.slice(start_idx, end_idx)
                let suffix = suggestion.slice(end_idx)
                return prefix + '<span class="highlight_match">' + match_text + "</span>" + suffix
            }

            function get_suggestion_description(sug) {
                if (sug === "\\frac") return "Define fraction"
                if (sug === "\\frac{}{}") return "Fraction snippet"
                if (sug.startsWith("\\vec{") && sug.length >= 6) {
                    let inside = sug.slice(5, -1) // e.g. AB
                    return "Vector " + inside
                }
                if (points_dict[sug]) {
                    return "Point " + sug
                }
                return "Vector / expression"
            }

            function replace_last_token_with(new_text) {
                let input = document.getElementById("vector_input")
                let full_str = input.value
                let caretPos = input.selectionEnd || full_str.length
                let { tokenStart, tokenEnd } = get_current_token(full_str, caretPos)

                let before = full_str.slice(0, tokenStart)
                let after = full_str.slice(tokenEnd)
                input.value = before + new_text + after

                let newPos = before.length + new_text.length
                input.setSelectionRange(newPos, newPos)
            }

            function get_current_token(full_str, caretPos) {
                if (caretPos > full_str.length) caretPos = full_str.length
                let start = 0
                for (let i = caretPos - 1; i >= 0; i--) {
                    if (TOKEN_DELIMITERS.test(full_str[i])) {
                        start = i + 1
                        break
                    }
                }
                let end = caretPos
                let tokenText = full_str.slice(start, end)
                return { tokenStart: start, tokenEnd: end, tokenText }
            }

            function build_all_suggestions() {
                let setOfAll = new Set()
                for (let lbl in points_dict) setOfAll.add(lbl)
                let pkeys = Object.keys(points_dict)
                for (let i = 0; i < pkeys.length; i++) {
                    for (let j = 0; j < pkeys.length; j++) {
                        if (i === j) continue
                        setOfAll.add(`\\vec{${pkeys[i]}${pkeys[j]}}`)
                    }
                }
                setOfAll.add("\\frac")
                setOfAll.add("\\frac{}{}")
                return setOfAll
            }

            function hide_autocomplete() {
                autocomplete_container.style.display = "none"
                current_suggestions = []
                selected_suggestion_index = 0
            }
            function show_autocomplete_container() {
                autocomplete_container.style.display = "flex"
            }

            function position_autocomplete_box() {
                let input = document.getElementById("vector_input")
                let rect = get_caret_coordinates(input)
                if (!rect) {
                    autocomplete_container.style.left = input.offsetLeft + "px"
                    autocomplete_container.style.top = input.offsetTop + input.offsetHeight + "px"
                    return
                }
                autocomplete_container.style.left = rect.left + "px"
                autocomplete_container.style.top = rect.top + rect.height + "px"
            }

            function get_caret_coordinates(input_el) {
                let selection_end = input_el.selectionEnd || 0
                let style = window.getComputedStyle(input_el)
                mirror_div.style.fontSize = style.fontSize
                mirror_div.style.fontFamily = style.fontFamily
                mirror_div.style.fontWeight = style.fontWeight
                mirror_div.style.letterSpacing = style.letterSpacing
                mirror_div.style.whiteSpace = "pre-wrap"
                mirror_div.style.width = input_el.offsetWidth + "px"
                mirror_div.style.padding = style.padding
                mirror_div.style.border = style.border
                mirror_div.style.boxSizing = style.boxSizing

                let text = input_el.value.substring(0, selection_end)
                text = text.replace(/\n/g, " ")
                mirror_div.textContent = text
                let caret_span = document.createElement("span")
                caret_span.textContent = "|"
                mirror_div.appendChild(caret_span)

                let mirror_rect = mirror_div.getBoundingClientRect()
                let caret_rect = caret_span.getBoundingClientRect()

                let caret_left = caret_rect.left - mirror_rect.left
                let caret_top = caret_rect.top - mirror_rect.top

                return {
                    left: mirror_div.offsetLeft + caret_left,
                    top: mirror_div.offsetTop + caret_top,
                    height: caret_span.offsetHeight,
                }
            }
        </script>
    </body>
</html>
